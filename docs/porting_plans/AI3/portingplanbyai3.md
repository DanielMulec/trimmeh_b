Architektonischer Entwurf für den KDE Plasma Port von Trimmeh: Erreichung absoluter funktionaler Parität mit TrimmyI. Zusammenfassung: Architektonische Übersetzung und ParitätsanforderungDieser Bericht liefert einen detaillierten, technischen Entwurf für die Portierung der GNOME Shell Extension trimmeh auf die KDE Plasma Desktop-Umgebung, primär ausgerichtet auf Plasma 6.4 und neuere Versionen unter Fedora 43. Die oberste Zielsetzung dieses Projekts ist die Erreichung absoluter funktionaler Parität (Parität) mit der ursprünglichen Trimmy-Anwendung und der bestehenden trimmeh-Codebasis für GNOME. Dies bedeutet, dass die Funktionalität und das kritische Zeitverhalten des KDE-Ports in jeder Hinsicht identisch sein müssen.A. Projektumfang und die zwingende Anforderung absoluter ParitätDie Anforderung geht über eine einfache Feature-Nachbildung hinaus. Sie verlangt die genaue Reproduktion des Anwendungsverhaltens, insbesondere hinsichtlich der kritischen Timing-Parameter. Die Analyse der Upstream-Codebasis (Trimmy) identifiziert zwei nicht verhandelbare Zeitkonstanten [1]: ein Abfrageintervall (Polling) von $\approx 150\,\text{ms}$ und eine zusätzliche Grace Delay von $\approx 80\,\text{ms}$, die dem System Zeit geben soll, versprochene Daten bereitzustellen.Da die Verteilung und das Packaging der Anwendung als sekundär betrachtet werden, liegt der Fokus des architektonischen Entwurfs ausschließlich auf der Sicherstellung, dass diese präzisen Funktionalitäten, die wahrscheinlich die Manipulation von Fenstergeometrien nach dem Kopieren von Inhalten beinhalten (ähnlich wie bei Fenstermanagement-Erweiterungen wie Tiling Assistant [2]), im KDE-Kontext fehlerfrei funktionieren.B. Grundlegende Architektonische Diskrepanz: GJS/GNOME Shell vs. C++/QML/KF6Die Herausforderung bei der Portierung liegt weniger in der Sprachübersetzung (JavaScript zu C++) als vielmehr in der Überbrückung fundamental unterschiedlicher Architekturmodelle:GNOME-Modell: GNOME Shell Extensions wie trimmeh werden in GJS (JavaScript-Bindungen für GNOME Platform APIs) geschrieben [3, 4]. Der Code läuft fest in den GNOME Shell-Prozess integriert. Dies bietet zwar einfachen Zugriff auf kritische APIs wie GSettings oder die Mutter-Fenster-APIs, bindet die Logik aber eng an die Lebensdauer der Shell.KDE-Modell: KDE Plasma 6 setzt standardmäßig auf eine entkoppelte Architektur. Die Benutzeroberfläche (UI/UX) wird deklarativ in QML geschrieben, oft unter Verwendung von Kirigami für konvergente Designs [5, 6]. Die geschäftslogischen und leistungskritischen Teile werden in kompiliertem C++ implementiert. Diese C++-Objekte werden über das Qt Meta Object System mit QML verbunden, meist als Signale, Slots oder Properties [7, 8]. Dieses Modell ist grundsätzlich robuster und bietet eine langlebigere API-Stabilität [9].Die Portierungsaufgabe erfordert daher eine Neukonzeption von einem integrierten Skript zu einem entkoppelten Dienst-Client-Modell.C. Vorgeschlagene KDE-Architektur: Das Hybrid-Persistenz-ModellUm die Anforderung eines permanenten Hintergrundprozesses, der notwendig ist, um die kontinuierliche Abfrage des Clipboards zu gewährleisten (ähnlich einer LSUIElement menu-bar app [1]), zu erfüllen, muss die Lösung über ein standardmäßiges, zustandsloses Plasmoid hinausgehen.Vorgeschlagene Architektur: Die Lösung wird als Plasma Widget (Plasmoid) konzipiert, das als Frontend dient und mit einem Persistenten C++ Dienst kommuniziert.Der C++ Dienst (TrimmehBackend) läuft kontinuierlich im Hintergrund. Er übernimmt die zeitkritischen Aufgaben wie die Abfrageschleife, die Clipboard-Überwachung und die Interprozesskommunikation (IPC) mit KWin.Der C++ Dienst muss sich als Status Notifier Item (SNI) registrieren, um im Systemabschnitt (System Tray) von Plasma sichtbar zu sein und die persistenten Statusanzeige des Originals zu replizieren [10].Das QML Plasmoid fungiert als leichter Client, der über eine C++-Singleton-Instanz die Zustandsdaten des persistenten Dienstes abruft und Einstellungen modifiziert [8].Die nachstehende Tabelle 1 zeigt die grundlegende Paritätsübersetzung der API-Ebenen von GNOME zu KDE Frameworks 6 (KF6).Tabelle 1: GNOME API zu KDE Frameworks 6 API ParitätsabbildungGNOME Komponente/API (Trimmeh)Funktion/FeatureKDE Frameworks 6 ÄquivalentImplementierungsdetailGJS/GNOME Shell ExtensionKernlogikausführungPersistenter C++ Dienst (QObject)Kompilierter C++ Backend für Leistung und Stabilität.GSettingsKonfigurationsmanagementKConfig (KF6)Einstellungen in ~/.config/trimmehrc. Erfordert D-Bus/Signal-Synchronisierung zur Laufzeit.Gdk/GNOME Clipboard APIClipboard-DatenüberwachungQClipboard::dataChanged() + QTimerHybrid Monitor in C++ zur Garantie der 150ms Polling-Parität.LSUIElement Menu-Bar AppPersistente SystempräsenzStatus Notifier Item (SNI)C++ Dienst, verwaltet über den Status Notifier Manager (kded) [10].Mutter Window API (Implizit)Tiling/FenstermanipulationKWin Scripting (D-Bus)Interaktion mit dem KWin-Prozess über D-Bus zur Änderung der Fenstergeometrie.II. Analyse der Quellcodebasen: Trimmy und Trimmeh AnforderungenDie Analyse der Quelldateien von Trimmeh und dem Upstream-Projekt Trimmy ist entscheidend, um die genauen funktionalen Anforderungen an den KDE-Port zu verstehen, insbesondere dort, wo Verhaltensweisen implementiert wurden, um spezifische Betriebssystembeschränkungen zu umgehen oder genaue Timing-Anforderungen zu erfüllen.A. Kernfunktionalität abgeleitet von TrimmyDie Originalanwendung Trimmy ist durch ihre expliziten Timing-Vorgaben definiert:Zwingende Polling-Vorgabe: Die Notwendigkeit einer kontinuierlichen Überprüfung alle $\approx 150\,\text{ms}$ [1] deutet darauf hin, dass reines ereignisgesteuertes Clipboard-Monitoring (z. B. auf Basis von Systemsignalen) in der ursprünglichen Implementierung als unzureichend oder unzuverlässig erachtet wurde. Diese strikte Frequenz muss im C++ Backend des KDE-Ports durch eine QTimer-Instanz exakt eingehalten werden, um die funktionale Parität zu gewährleisten.Die 80ms Grace Delay: Die zusätzliche Verzögerung von $\approx 80\,\text{ms}$ nach einer festgestellten Clipboard-Änderung [1] dient wahrscheinlich dazu, Race Conditions zu vermeiden, insbesondere wenn Clipboard-Inhalte asynchron von der kopierenden Anwendung bereitgestellt werden (Promised Data). Diese Verzögerung muss im C++ Backend durch einen gezielten QSingleShotTimer implementiert werden, der die eigentliche Verarbeitungslogik erst nach Ablauf der Zeit startet.Persistenz und Systemabschnitt: Die Beschreibung als LSUIElement menu-bar app [1] bestätigt die Notwendigkeit eines leichten, persistenten Hintergrundprozesses ohne Hauptfenster. Im KDE-Kontext wird diese Funktionalität durch die Implementierung eines Status Notifier Items (SNI) über das kded-Subsystem erreicht [10]. Der C++ Dienst muss diesen Mechanismus nutzen, um im Plasma Systemabschnitt dauerhaft präsent zu sein.B. Implementierungs-Stack des GNOME Ports (Trimmeh)Trimmeh nutzt GJS und die damit verbundenen GNOME-Plattform-APIs [3, 4].GSettings Konfiguration: Trimmeh verwendet GSettings zur Speicherung seiner Einstellungen. Um Parität zu erreichen, muss die gesamte Struktur des GSettings-Schemas (einschließlich Schlüsselnamen, Datentypen und Standardwerte) aus der trimmeh-Codebasis extrahiert werden. Dies ist die Grundlage für die Erstellung des äquivalenten KDE-Konfigurationsschemas (KConfig) [11].Window Management Implikationen: Obgleich die genaue "Trimming"-Aktion nicht explizit in den bereitgestellten Informationen beschrieben wird, impliziert der Kontext (ähnlich Tiling Assistant [2]), dass die Anwendung Fenstergeometrien oder -layouts basierend auf kopierten Inhalten manipuliert. Im GNOME-Umfeld erfolgt dies über proprietäre Mutter-APIs. Im KDE-Umfeld muss diese Interaktion über die KWin Scripting API (verfügbar über D-Bus) nachgebildet werden.Die Notwendigkeit einer strikten Einhaltung des 150ms-Intervalls führt zur Schlussfolgerung, dass die Portierung eine Hybride Clipboard-Überwachung verwenden muss. Während moderne Qt-APIs wie QClipboard::dataChanged() eine effiziente, ereignisbasierte Erkennung ermöglichen [12], muss das Polling-Schema von Trimmy als Fallback und zur Validierung der Timing-Parität explizit beibehalten werden. Dies ist ein kritischer Punkt, da eine Vernachlässigung des Polling-Intervalls die Parität in Bezug auf das beabsichtigte Timing-Verhalten von Trimmy unterbrechen würde.III. KDE Plasma 6.4 Entwicklungsarchitektur-BlueprintDie Zielplattform Plasma 6.4 unter Fedora 43 erfordert die ausschließliche Verwendung von Qt 6 und den KDE Frameworks 6 (KF6).A. Technologischer Basis-Stack für Fedora 43Die Architektur des KDE-Ports muss auf den folgenden Komponenten basieren:C++ und Qt 6: Die Kernlogik, einschließlich der Clipboard-Überwachung und der Timing-Logik, muss in C++ implementiert werden. C++-Klassen müssen von QObject ableiten, um Slots, Signale und Properties zur Integration mit QML bereitzustellen [7, 8].KDE Frameworks 6 (KF6):Kirigami & QQC2: Kirigami und die Qt Quick Controls 2 (QQC2) dienen als Grundlage für das responsive und konvergente Design des Plasmoid-Frontends [6, 13].KConfig: KF6-Konfigurationssystem für die dauerhafte Speicherung von Benutzereinstellungen [11].D-Bus APIs: Notwendig für die Interprozesskommunikation (IPC) mit KWin und dem Status Notifier Manager [14].Für die Entwicklung auf Fedora 43 müssen spezifische KF6-Pakete installiert werden, wie beispielsweise kf6-kirigami-devel und verwandte Qt 6 Entwicklungsbibliotheken [15, 16].B. Das KDE-Komponentenmodell: Plasmoid und C++ Backend-IntegrationDie Umsetzung der Anwendung erfordert die strikte Trennung von Logik (C++) und Präsentation (QML), verbunden über das Meta Object System.1. Der C++ Backend (TrimmehBackend)Die Klasse TrimmehBackend (abgeleitet von QObject) ist das Herzstück des Systems. Ihre Verantwortlichkeiten umfassen:Timing Management: Verwaltung des $\approx 150\,\text{ms}$ Polling-QTimer und des $80\,\text{ms}$ Grace Delay-Timers.Systemintegration: Instanziierung des TrimmehClipboardMonitor und Verwaltung der KConfig-Operationen.IPC-Gateway: Bereitstellung von Methoden (Slots), um D-Bus-Befehle an KWin zu senden.Diese Klasse muss in der C++-Anwendung als Singleton registriert werden (qmlRegisterSingletonInstance<TrimmehBackend>(...)) [8]. Die Verwendung eines Singletons stellt sicher, dass der langlebige Überwachungsdienst nur einmal instanziiert wird, seinen Zustand beibehält und einfach vom QML-Frontend über ein stabiles Interface (import org.kde.trimmeh 1.0; Backend...) angesprochen werden kann.2. Das Plasmoid Frontend (QML)Das Plasmoid selbst folgt der standardmäßigen Plasma Widget-Struktur [17, 18].Struktur: Erstellung einer package-Struktur mit metadata.json, contents/ui/main.qml und contents/config/main.xml.Interaktion: Das QML-Frontend greift auf Properties, Slots und Signale des C++ Singletons zu. Beispielsweise zeigt es den aktuellen Clipboard-Text an (Backend.currentClipboardText) oder ruft die Trimming-Logik auf (Backend.triggerTrimAction()) [19].C. Inter-Prozess-Kommunikation (IPC) StrategieDer entkoppelte Aufbau von KDE erfordert eine robuste IPC-Strategie:D-Bus: Dies ist der primäre Mechanismus zur Kommunikation mit anderen Kerndiensten unter Plasma [14]. D-Bus wird verwendet, um:Fensterbefehle an KWin (den Fenstermanager) zu senden.Den Status Notifier Manager zu steuern.Status Notifier Item (SNI): Um die Persistenz der menu-bar app zu gewährleisten, muss der C++ Dienst als Status Notifier Item konfiguriert werden. Der Status Notifier Manager (der Teil von kded ist) hostet diese persistenten Hintergrundanwendungen im Systemabschnitt [10]. Dies gewährleistet, dass der Dienst unabhängig vom Zustand des QML-Plasmoids läuft.IV. Feature-Paritätsabbildung und präskriptiver ImplementierungsplanDie technische Herausforderung liegt in der exakten Nachbildung der Kernfunktionen, insbesondere der zeitkritischen Abläufe.A. Konfigurationspersistenz (GSettings zu KConfig Parität)Alle Einstellungen, die in trimmeh über GSettings verwaltet werden, müssen in das KConfig-System von KF6 überführt werden.KConfig Struktur: Die Einstellungen werden in einer dedizierten Datei (z. B. ~/.config/trimmehrc) gespeichert, wobei Gruppen und Schlüssel die GSettings-Pfade nachbilden [11].Synchronisation zur Laufzeit: GSettings verwendet einen signalbasierten Mechanismus für sofortige Konfigurationsänderungen. Im Gegensatz dazu erfordern KConfig-Schreibvorgänge oft eine explizite Neuladung oder einen Neustart des betroffenen Komponenten [11]. Um Parität zu gewährleisten, muss die Plasmoid-Konfigurations-UI (z. B. configGeneral.qml) nach dem Speichern der Einstellungen (durch den Benutzer) einen Slot im TrimmehBackend aufrufen. Dieser Slot muss sofort die KConfig-Instanz neu laden und die neuen Polling-Parameter auf den laufenden QTimer anwenden.QML-Konfigurations-UI: Die Definition der Konfigurationsschlüssel erfolgt über die XML-Schema-Datei main.xml innerhalb des Plasmoid-Pakets, wobei die Benutzeroberfläche in QML (z. B. configGeneral.qml) die Konfigurationsschlüssel über die PlasmaCore-APIs anspricht.B. Kritische Parität: Hybrid-Clipboard-Überwachung und TimingDie Umsetzung der strengen Timing-Anforderungen ($150\,\text{ms}$ Polling, $80\,\text{ms}$ Grace Delay) ist der kritischste Aspekt des Ports.1. Implementierung des Clipboard-ProxysDer C++ Backend muss die systemspezifische Clipboard-API von Qt, die Klasse QClipboard, kapseln, um sie sicher für QML verfügbar zu machen.TrimmehClipboardMonitor Klasse: Diese C++-Klasse wird von QObject abgeleitet und fungiert als Proxy [20]. Sie beinhaltet ein Q_PROPERTY für den aktuellen Text und Signale, um Änderungen an das QML-Frontend weiterzuleiten (siehe Tabelle 2).2. Der Hybride ÜberwachungsmechanismusUm die Parität mit den $\approx 150\,\text{ms}$ Polling-Anforderungen zu gewährleisten, wird ein zweistufiges System verwendet:Ereignisgesteuert (Effizienz): Der TrimmehClipboardMonitor verbindet sich mit dem Signal QClipboard::dataChanged() [12]. Dies ist der effizienteste Weg, systemweite Änderungen zu erfassen, unabhängig davon, ob das System X11 oder Wayland nutzt.Polling-Erzwingung (Parität): Parallel dazu muss der TrimmehBackend einen $\approx 150\,\text{ms}$ QTimer ausführen. Der Slot, der mit diesem Timer verbunden ist, führt eine manuelle Clipboard-Prüfung durch. Dieses Polling dient als explizite Erfüllung der Trimmy-Vorgabe [1] und bietet eine robuste Fehlerbehandlung für potenzielle Wayland-spezifische Probleme bei der Clipboard-Synchronisation [21].3. Grace Delay ImplementierungSobald der Hybride Monitor eine Clipboard-Änderung erkennt (entweder durch Signal oder Polling), darf die Verarbeitungslogik nicht sofort ausgeführt werden.Ein $80\,\text{ms}$ QSingleShotTimer wird gestartet.Die eigentliche "Trimming"-Logik (d. h. die Verarbeitung des kopierten Inhalts und die mögliche Fenster-Aktion) wird ausschließlich im Slot ausgeführt, der mit dem Ablauf (timeout()) dieses 80ms-Timers verbunden ist.Dies garantiert die genaue Einhaltung der kritischen Zeitparameter aus der Originalanwendung.Tabelle 2: C++ Backend API Exposure zu QML FrontendC++ TrimmehBackend (QObject)TypQML Interaktion (Beispiel)ParitätszielcurrentClipboardTextQ_PROPERTY(QString READ...)Backend.currentClipboardTextExponiert den Clipboard-Inhalt zur Laufzeit.pollingIntervalQ_PROPERTY(int READ WRITE...)Backend.pollingInterval = 150Liest/schreibt KConfig-Werte und wendet diese sofort auf den QTimer an.clipboardDataChanged()Q_SIGNALonClipboardDataChanged:...Ereignisbenachrichtigung an die UI-Ebene.triggerTrimAction(layoutID)Q_SLOTBackend.triggerTrimAction(1)QML ruft die C++-Methode zur Interaktion mit KWin auf.C. Systemabschnitts- und Dienstverwaltungs-ParitätDie C++ Anwendung muss sich korrekt als Status Notifier Item (SNI) registrieren.SNI-Integration: Der C++ Dienst muss die notwendigen KF6-Komponenten verwenden, um eine Schnittstelle zum Status Notifier Manager bereitzustellen, der von kded verwaltet wird [10]. Dies repliziert die permanente System-Tray-Präsenz, die für die LSUIElement Funktionalität erforderlich ist.Fokus-Steuerung: Falls das Klicken auf das SNI-Icon eine GUI öffnen oder ein Fenster in den Vordergrund bringen soll, muss der C++ Dienst präzise die Qt/KDE-Fenster-APIs nutzen, um Fokus-Diebstahl-Präventionseinstellungen von KWin zu berücksichtigen und die Anwendung korrekt zu aktivieren [22].D. Erweiterte Parität: KWin-Fenstermanagement-IntegrationWenn die "Trimming"-Funktionalität die Manipulation von Fenstern beinhaltet (Tiling, Snapping oder Größenänderung [2]), ist eine tiefgreifende Interaktion mit KWin erforderlich.KWin Scripting API: Der sicherste und am besten unterstützte Weg zur Änderung von Fenstergeometrien in KDE ist die Verwendung der KWin Scripting API. Diese Skripte können in JavaScript oder QML geschrieben werden und sind direkt in den Fenstermanager-Prozess integriert.C++ IPC Brücke: Der TrimmehBackend C++ Dienst darf Fensteraktionen nicht direkt ausführen. Stattdessen sendet er über D-Bus einen Befehl an den KWin-Prozess, der wiederum das dedizierte KWin Script auslöst. Dieses Skript führt dann die gewünschte Größenänderungs- oder Positionierungslogik aus. Diese D-Bus-Brücke gewährleistet, dass die Fenstersteuerung die Funktionalität der ursprünglichen GNOME/Mutter-Skripte unter Verwendung des nativen KDE-Mechanismus nachbildet [23].V. Entwicklungsworkflow und Umgebungseinrichtung (Fedora 43)Die Einhaltung der Zielumgebung (KDE Plasma 6.4 auf Fedora 43) erfordert eine spezifische Build- und Debugging-Strategie, die auf Qt 6 und KF6 ausgerichtet ist.A. Erforderliche Build-Umgebungseinrichtung (Fedora 43)Um eine kompatible Anwendung für Plasma 6.4 unter Fedora 43 zu erstellen, müssen die korrekten Entwicklungsbibliotheken installiert werden, wobei die Nomenklatur von Fedora für KF6 beachtet werden muss.Build Toolchain: Installation von cmake und einem C++-Compiler (GCC/Clang). Die Verwendung von CMake ist obligatorisch für die Integration von KF6-Modulen.Abhängigkeitsinstallation (KF6/Qt6):qt6-qtdeclarative-devel: Bereitstellung des QML-Laufzeitumfelds.kf6-kirigami-devel: Enthält die notwendigen Header und Bibliotheken für Kirigami, essentiell für die Erstellung der UI [15].libkf6coreaddons-devel: Für grundlegende KF6-Dienstprogramme [16].kf6-plasma-devel: Bereitstellung von Plasma-spezifischen APIs wie PlasmaCore.Die korrekte Konfiguration der CMakeLists.txt muss sicherstellen, dass alle erforderlichen KF6-Komponenten mit find_package(KF6 REQUIRED COMPONENTS...) gefunden und verlinkt werden, um Laufzeitfehler zu vermeiden.B. Entwicklung und Debugging-WorkflowDie Entwicklung muss die getrennten Natur des Plasmoid-Frontends und des C++ Backends berücksichtigen.UI-Iteration: Für die schnelle Entwicklung der QML-Benutzeroberfläche und des Konfigurationsfensters (z. B. main.qml, configGeneral.qml) ist das Werkzeug plasmoidviewer zu verwenden. Durch den Befehl plasmoidviewer -a. im Hauptverzeichnis des Widgets können QML-Änderungen schnell getestet werden, ohne die gesamte Plasma-Shell neu starten zu müssen [18].C++ Dienst Debugging: Der persistente C++ Dienst muss mit Standard-Linux-Tools wie GDB debuggt werden. Besondere Aufmerksamkeit ist auf die Einhaltung des $150\,\text{ms}$ Timings zu legen, die korrekte Lebenszyklusverwaltung der QObject-Instanzen, die SNI-Registrierung und die Stabilität der D-Bus-Kommunikation mit KWin.Lokale Installation und Systemtest: Die vollständige Systemintegration, einschließlich der SNI-Präsenz, der Interaktion mit dem Clipboard-System und der KWin-Befehle, muss nach lokaler Installation getestet werden. Dies geschieht durch plasmapkg2 -i., wodurch das Plasmoid in das Verzeichnis ~/.local/share/plasma/plasmoids/ installiert wird [18].C. Codebasis-Management-StrukturDie Codebasis sollte der empfohlenen Plasma-Widget-Struktur folgen:Top-Level: Das Hauptverzeichnis des Projekts.package/: Enthält alle Dateien, die zur Installation des Plasmoids erforderlich sind.metadata.json: Definiert Metadaten und den Einstiegspunkt des Widgets.contents/ui/: Beinhaltet die QML-Layout-Dateien (main.qml).contents/config/: Beinhaltet die Konfigurationsdateien (main.xml, configGeneral.qml).Die C++ Quell- und Header-Dateien (trimmehbackend.cpp, trimmehclipboardmonitor.h) sollten außerhalb des package/-Verzeichnisses auf der obersten Ebene liegen und mittels CMake in eine ausführbare Plasmoid-Binary kompiliert werden, die dann im package/ Verzeichnis abgelegt wird.VI. Schlussfolgerungen und EmpfehlungenDer Port von trimmeh zu KDE Plasma 6.4 kann nur dann absolute funktionale Parität mit Trimmy erreichen, wenn die Architektur radikal von einem In-Shell-Skript (GJS) zu einem Hybrid-C++/QML-Dienst-Modell wechselt.Die entscheidende technische Herausforderung, die bewältigt werden muss, ist die strikte Einhaltung der Timing-Anforderungen ($150\,\text{ms}$ Polling, $80\,\text{ms}$ Grace Delay) [1]. Eine einfache Implementierung, die sich nur auf das Signal QClipboard::dataChanged() verlässt, würde die Verhaltensparität unterbrechen. Die Verwendung eines dedizierten, persistenten C++-Hintergrunddienstes, der sowohl ereignisgesteuert als auch über einen QTimer aktiv überwacht, ist zwingend erforderlich.Maßnahmenempfehlungen:Priorisierung des Backends: Die Implementierung des C++ TrimmehBackend Singletons und des TrimmehClipboardMonitor (einschließlich der Timer-Logik) sollte die erste Entwicklungsphase darstellen. Der C++ Code muss dabei stabil laufen und die Status Notifier Item (SNI)-Registrierung erfolgreich durchführen, um die notwendige Persistenz zu gewährleisten [10].API-Brückenkonstruktion: Der C++ Backend muss alle notwendigen Funktionen (Fenstermanipulation, Konfigurationsänderungen) als Q_SLOT oder Q_PROPERTY definieren (siehe Tabelle 2), bevor die QML-Frontend-Entwicklung beginnt.KWin-Abstraktion: Die Logik zur Fensterpositionierung sollte als KWin Script implementiert werden, um die systemeigenen APIs von KDE zu nutzen. Die C++-Schicht dient lediglich als D-Bus-Kommunikationsbrücke, die das Skript auf Basis der Clipboard-Daten auslöst.Durch die Einhaltung dieser architektonischen Spezifikationen wird sichergestellt, dass der KDE Plasma Port von trimmeh die geforderte Funktionalitäts- und Zeitparität mit dem Upstream-Projekt vollständig erreicht.